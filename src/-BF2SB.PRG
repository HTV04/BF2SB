'BF2SB v2.2.1 (otyaSB)
'By HTV04

'IMPORTANT: Read "-README.TXT" for
'documentation and other information. If you
'need to look at this document for reference,
'open it in SLOT 3 for easy access.

'NOTE: The "Options" section of this program
'is intended for advanced users who want to
'alter how brainf**k code is converted.

OPTION STRICT
ACLS

'--Options--
'-Brainf**k Code Options-
VAR OPTIMIZE=1
VAR MEMSIZE=30000
VAR BITWIDTH=0
VAR SIGNEDINT=1

'--

'-Converted Code Options-
VAR SBCOMMENT=1
VAR SBOPTIMIZE=1
VAR SBMEMOF=0
VAR SBCHR13=1
VAR SBINPUT=1
VAR SBINPUT$=""
VAR SBINPUTEOF=2
VAR SBWAIT=0
VAR SBWAITCNT=1
VAR SBINDENT=1
VAR SBNEWLINES=1

'--

'----

'--Setup--
VAR VER$="2.2 (SB3)"
PRINT "BF2SB v"+VER$
PRINT "By HTV04"
PRINT ""

'----

'--Option Fail-safes--
IF OPTIMIZE!=0 THEN
 IF OPTIMIZE!=1 THEN
  GOTO @FAILSAFE
 ENDIF
ENDIF
IF MEMSIZE<0 THEN
 GOTO @FAILSAFE
ELSEIF MEMSIZE!=FLOOR(MEMSIZE) THEN
 GOTO @FAILSAFE
ENDIF
IF BITWIDTH!=0 THEN
 IF BITWIDTH!=1 THEN
  IF BITWIDTH!=2 THEN
   GOTO @FAILSAFE
  ENDIF
 ENDIF
ENDIF
IF SIGNEDINT!=0 THEN
 IF SIGNEDINT!=1 THEN
  GOTO @FAILSAFE
 ENDIF
ENDIF

IF SBCOMMENT!=0 THEN
 IF SBCOMMENT!=1 THEN
  GOTO @FAILSAFE
 ENDIF
ENDIF
IF SBOPTIMIZE!=0 THEN
 IF SBOPTIMIZE!=1 THEN
  GOTO @FAILSAFE
 ENDIF
ENDIF
IF SBMEMOF!=0 THEN
 IF SBMEMOF!=1 THEN
  GOTO @FAILSAFE
 ENDIF
ENDIF
IF SBCHR13!=0 THEN
 IF SBCHR13!=1 THEN
  GOTO @FAILSAFE
 ENDIF
ENDIF
IF SBINPUT!=0 THEN
 IF SBINPUT!=1 THEN
  GOTO @FAILSAFE
 ENDIF
ENDIF
IF SBINPUTEOF!=0 THEN
 IF SBINPUTEOF!=1 THEN
  IF SBINPUTEOF!=2 THEN
   GOTO @FAILSAFE
  ENDIF
 ENDIF
ENDIF
IF SBWAIT!=0 THEN
 IF SBWAIT!=1 THEN
  GOTO @FAILSAFE
 ENDIF
ENDIF
IF SBINDENT!=0 THEN
 IF SBINDENT!=1 THEN
  GOTO @FAILSAFE
 ENDIF
ENDIF
IF SBNEWLINES!=0 THEN
 IF SBNEWLINES!=1 THEN
  GOTO @FAILSAFE
 ENDIF
ENDIF

GOTO @CHECKPASS

@FAILSAFE
PRINT "ERROR: One or more options are set incorrectly:"
IF OPTIMIZE!=0 THEN
 IF OPTIMIZE!=1 THEN
  PRINT "- OPTIMIZE"
 ENDIF
ENDIF
IF MEMSIZE<0 THEN
 PRINT "- MEMSIZE"
ELSEIF MEMSIZE!=FLOOR(MEMSIZE) THEN
 PRINT "- MEMSIZE"
ENDIF
IF BITWIDTH!=0 THEN
 IF BITWIDTH!=1 THEN
  IF BITWIDTH!=2 THEN
   PRINT "- BITWIDTH"
  ENDIF
 ENDIF
ENDIF
IF SIGNEDINT!=0 THEN
 IF SIGNEDINT!=1 THEN
  PRINT "- SIGNEDINT"
 ENDIF
ENDIF
PRINT ""
IF SBCOMMENT!=0 THEN
 IF SBCOMMENT!=1 THEN
  PRINT "- SBCOMMENT"
 ENDIF
ENDIF
IF SBOPTIMIZE!=0 THEN
 IF SBOPTIMIZE!=1 THEN
  PRINT "- SBOPTIMIZE"
 ENDIF
ENDIF
IF SBMEMOF!=0 THEN
 IF SBMEMOF!=1 THEN
  PRINT "- SBMEMOF"
 ENDIF
ENDIF
IF SBCHR13!=0 THEN
 IF SBCHR13!=1 THEN
  PRINT "- SBCHR13"
 ENDIF
ENDIF
IF SBINPUT!=0 THEN
 IF SBINPUT!=1 THEN
  PRINT "- SBINPUT"
 ENDIF
ENDIF
IF SBINPUTEOF!=0 THEN
 IF SBINPUTEOF!=1 THEN
  IF SBINPUTEOF!=2 THEN
   PRINT "- SBINPUTEOF"
  ENDIF
 ENDIF
ENDIF
IF SBWAIT!=0 THEN
 IF SBWAIT!=1 THEN
  PRINT "- SBWAIT"
 ENDIF
ENDIF
IF SBINDENT!=0 THEN
 IF SBINDENT!=1 THEN
  PRINT "- SBINDENT"
 ENDIF
ENDIF
IF SBNEWLINES!=0 THEN
 IF SBNEWLINES!=1 THEN
  PRINT "- SBNEWLINES"
 ENDIF
ENDIF
PRINT ""
PRINT "Please set the values for these options correctly."
END

@CHECKPASS

'----

'--Bit Width Setup--
'Thanks to the weird way STR$ works, I have
'to do this!
VAR BITC$,BITU$,BITL$
IF SIGNEDINT==0 THEN
 IF BITWIDTH==0 THEN
  BITC$="256"
  BITU$="255"
  BITL$="0"
 ENDIF
 IF BITWIDTH==1 THEN
  BITC$="65536"
  BITU$="65535"
  BITL$="0"
 ENDIF
 IF BITWIDTH==2 THEN
  BITC$="4294967296"
  BITU$="4294967295"
  BITL$="0"
 ENDIF
ENDIF
IF SIGNEDINT==1 THEN
 IF BITWIDTH==0 THEN
  BITC$="256"
  BITU$="127"
  BITL$="-128"
 ENDIF
 IF BITWIDTH==1 THEN
  BITC$="65536"
  BITU$="32767"
  BITL$="-32768"
 ENDIF
 IF BITWIDTH==2 THEN
  BITC$="4294967296"
  BITU$="2147483647"
  BITL$="-2147483648"
 ENDIF
ENDIF

'----

'--EOF Setup--
VAR SBEOF$
IF SBINPUTEOF==0 THEN SBEOF$="0"
IF SBINPUTEOF==1 THEN SBEOF$="-1"

'----

'--Code Minification--
VAR I,I1
VAR G$,TEST$,S$
PRINT "Reading... ";
FOR I=1 TO PRGSIZE(1)
 PRGEDIT 1,I
 G$=PRGGET$()
 FOR I1=0 TO LEN(G$)-1
  TEST$=MID$(G$,I1,1)
  IF TEST$=="+" THEN
   S$=S$+"+"
  ENDIF
  IF TEST$=="-" THEN
   S$=S$+"-"
  ENDIF
  IF TEST$==">" THEN
   S$=S$+">"
  ENDIF
  IF TEST$=="<" THEN
   S$=S$+"<"
  ENDIF
  IF TEST$=="[" THEN
   S$=S$+"["
  ENDIF
  IF TEST$=="]" THEN
   S$=S$+"]"
  ENDIF
  IF TEST$=="." THEN
   S$=S$+"."
  ENDIF
  IF TEST$=="," THEN
   S$=S$+","
  ENDIF
 NEXT
NEXT
PRINT "Done."

'----

'--Code Optimization--
VAR OLDS$=S$
IF OPTIMIZE==1 THEN
 PRINT "Optimizing... ";
 REPEAT
  S$=REPLACE$(S$,"+-","")
 UNTIL COUNT(S$,"+-")==0
 REPEAT
  S$=REPLACE$(S$,"-+","")
 UNTIL COUNT(S$,"-+")==0
 PRINT "Done."
ENDIF

'----

'--Conversion Setup--
VAR PRG$,ICOUNT
PRGEDIT 2
PRGDEL -1
PRINT "Commenting... ";
EXTENDPRGBF "'Converted using BF2SB v"+VER$+" by HTV04"
EXTENDPRGBF ""
IF OPTIMIZE==0 THEN
 EXTENDPRGBF "'Source optimization: Off"
ENDIF
IF OPTIMIZE==1 THEN
 EXTENDPRGBF "'Source optimization: On"
ENDIF
EXTENDPRGBF "'Memory size: "+STR$(MEMSIZE)
EXTENDPRGBF "'Bit width: "+STR$(BITWIDTH)
IF SIGNEDINT==0 THEN
 EXTENDPRGBF "'Signed integers: No"
ENDIF
IF SIGNEDINT==1 THEN
 EXTENDPRGBF "'Signed integers: Yes"
ENDIF
EXTENDPRGBF ""
IF SBOPTIMIZE==0 THEN
 EXTENDPRGBF "'Code optimization: Off"
ENDIF
IF SBOPTIMIZE==1 THEN
 EXTENDPRGBF "'Code optimization: On"
ENDIF
IF SBINPUT==0 THEN
 EXTENDPRGBF "'Input: From string"
ENDIF
IF SBINPUT==1 THEN
 EXTENDPRGBF "'Input: Wait"
ENDIF
EXTENDPRGBF ""
IF SBCOMMENT==1 THEN
 IF OPTIMIZE==0 THEN
  EXTENDPRGBF "'Source code ("+STR$(LEN(S$))+" characters):"
  EXTENDPRGBF "'"+S$
  EXTENDPRGBF ""
 ENDIF
 IF OPTIMIZE==1 THEN
  IF S$!=OLDS$ THEN
   EXTENDPRGBF "'Optimized source code ("+STR$(LEN(S$))+" characters):"
   EXTENDPRGBF "'"+S$
   EXTENDPRGBF ""
   EXTENDPRGBF "'Original source code ("+STR$(LEN(OLDS$))+" characters):"
   EXTENDPRGBF "'"+OLDS$
   EXTENDPRGBF ""
  ELSE
   EXTENDPRGBF "'Source code ("+STR$(LEN(S$))+" characters):"
   EXTENDPRGBF "'"+S$
   EXTENDPRGBF ""
  ENDIF
 ENDIF
ENDIF
EXTENDPRGBF "OPTION STRICT"
EXTENDPRGBF "ACLS"
EXTENDPRGBF ""
IF SBCOMMENT==1 THEN
 EXTENDPRGBF "'--Setup--"
ENDIF
EXTENDPRGBF "DIM MEM["+STR$(MEMSIZE)+"]"
IF SBINPUT==0 THEN
 EXTENDPRGBF "VAR P,IC"
 EXTENDPRGBF "VAR Q$="+CHR$(34)+SBINPUT$+CHR$(34)
ENDIF
IF SBINPUT==1 THEN
 EXTENDPRGBF "VAR P,Q$"
ENDIF
EXTENDPRGBF ""
IF SBCOMMENT==1 THEN
 EXTENDPRGBF "'----"
 EXTENDPRGBF ""
 EXTENDPRGBF "'--Converted Code--"
ENDIF
PRINT "Done."

IF SBOPTIMIZE==1 THEN
 S$=REPLACE$(S$,"[-]","A")
 S$=REPLACE$(S$,"[+]","A")
ENDIF
PRINT "Converting... ";
FOR I=0 TO LEN(S$)-1
 TEST$=MID$(S$,I,1)
 IF TEST$=="+" THEN
  PRGINSBFINC
 ENDIF
 IF TEST$=="-" THEN
  PRGINSBFDEC
 ENDIF
 IF TEST$==">" THEN
  PRGINSBFRIGHT
 ENDIF
 IF TEST$=="<" THEN
  PRGINSBFLEFT
 ENDIF
 IF TEST$=="[" THEN
  PRGINSBFWHILE
 ENDIF
 IF TEST$=="]" THEN
  PRGINSBFWEND
 ENDIF
 IF TEST$=="." THEN
  PRGINSBFPRINT
 ENDIF
 IF TEST$=="," THEN
  PRGINSBFINPUT
 ENDIF
 IF SBOPTIMIZE==1 THEN
  IF TEST$=="A" THEN
   PRGINSBFOPTA
  ENDIF
 ENDIF
 IF SBWAIT==1 THEN
  EXTENDPRGBF "WAIT "+STR$(SBWAITCNT)
 ENDIF
 IF SBNEWLINES==1 THEN
  EXTENDPRGBF ""
 ENDIF
NEXT
PRINT "Done."
IF SBCOMMENT==1 THEN
 IF SBNEWLINES==0 THEN
  EXTENDPRGBF ""
 ENDIF
 EXTENDPRGBF "'----"
ENDIF
PRINT "Preparing... ";
PRGINS PRG$
PRGEDIT 2,-1
PRGDEL
PRINT "Done."

PRINT ""
PRINT "Finished. Running..."

EXEC 2

'----

'--Library--
DEF REPLACE$(S$,O$,N$) 'From YARN.LIB v1.2
 VAR W$,I%,S%
 VAR L%=LEN(O$)
 VAR N%=LEN(N$)
 W$=S$+""
 
 I%=INSTR(W$,O$)
 WHILE I%!=-1
  W$=SUBST$(W$,I%,L%,N$)
  S%=I%+N%
  I%=INSTR(S%,W$,O$)
 WEND
 
 RETURN W$
END

DEF COUNT(S$,U$) 'From YARN.LIB v1.2
 VAR O%,I%,S%
 
 REPEAT
  I%=INSTR(S%,S$,U$)
  INC O%,I%!=-1
  INC S%,LEN(U$)
 UNTIL I%==-1||S%>=LEN(S$)
 RETURN O%
END

DEF EXTENDPRGBF S$
 PRG$=PRG$+BFCLINE$(S$)
END

DEF BFCLINE$(S$)
 RETURN (" "*ICOUNT)+S$+CHR$(10)
END

DEF PRGINSBFINC
 IF SBOPTIMIZE==0 THEN
  EXTENDPRGBF "INC MEM[P]"
  EXTENDPRGBF "IF MEM[P]>"+BITU$+" THEN"
  IF SBINDENT==0 THEN
   EXTENDPRGBF "REPEAT"
   EXTENDPRGBF "DEC MEM[P],"+BITC$
   EXTENDPRGBF "UNTIL MEM[P]<="+BITU$
  ENDIF
  IF SBINDENT==1 THEN
   EXTENDPRGBF " REPEAT"
   EXTENDPRGBF "  DEC MEM[P],"+BITC$
   EXTENDPRGBF " UNTIL MEM[P]<="+BITU$
  ENDIF
  EXTENDPRGBF "ENDIF"
 ENDIF
 IF SBOPTIMIZE==1 THEN
  I=BFINC(I,S$)
 ENDIF
END

DEF PRGINSBFDEC
 IF SBOPTIMIZE==0 THEN
  EXTENDPRGBF "DEC MEM[P]"
  EXTENDPRGBF "IF MEM[P]<"+BITL$+" THEN"
  IF SBINDENT==0 THEN
   EXTENDPRGBF "REPEAT"
   EXTENDPRGBF "INC MEM[P],"+BITC$
   EXTENDPRGBF "UNTIL MEM[P]>="+BITL$
  ENDIF
  IF SBINDENT==1 THEN
   EXTENDPRGBF " REPEAT"
   EXTENDPRGBF "  INC MEM[P],"+BITC$
   EXTENDPRGBF " UNTIL MEM[P]>="+BITL$
  ENDIF
  EXTENDPRGBF "ENDIF"
 ENDIF
 IF SBOPTIMIZE==1 THEN
  I=BFDEC(I,S$)
 ENDIF
END

DEF PRGINSBFRIGHT
 IF SBOPTIMIZE==0 THEN
  EXTENDPRGBF "INC P"
 ENDIF
 IF SBOPTIMIZE==1 THEN
  I=BFRIGHT(I,S$)
 ENDIF
 IF SBMEMOF==0 THEN
  EXTENDPRGBF "IF P>="+STR$(MEMSIZE)+" THEN"
  IF SBINDENT==0 THEN
   EXTENDPRGBF "REPEAT"
   EXTENDPRGBF "DEC P,"+STR$(MEMSIZE)
   EXTENDPRGBF "UNTIL P<"+STR$(MEMSIZE)
  ENDIF
  IF SBINDENT==1 THEN
   EXTENDPRGBF " REPEAT"
   EXTENDPRGBF "  DEC P,"+STR$(MEMSIZE)
   EXTENDPRGBF " UNTIL P<"+STR$(MEMSIZE)
  ENDIF
  EXTENDPRGBF "ENDIF"
 ENDIF
 IF SBMEMOF==1 THEN
  EXTENDPRGBF "IF P>="+STR$(MEMSIZE)+" THEN"
  IF SBINDENT==0 THEN
   EXTENDPRGBF "CLS"
   EXTENDPRGBF "DIALOG "+CHR$(34)+"Memory overflow. Execution halted."+CHR$(34)+",0,"+CHR$(34)+"ABORT"+CHR$(34)
   EXTENDPRGBF "END"
  ENDIF
  IF SBINDENT==1 THEN
   EXTENDPRGBF " CLS"
   EXTENDPRGBF " DIALOG "+CHR$(34)+"Memory overflow. Execution halted."+CHR$(34)+",0,"+CHR$(34)+"ABORT"+CHR$(34)
   EXTENDPRGBF " END"
  ENDIF
 EXTENDPRGBF "ENDIF"
 ENDIF
END

DEF PRGINSBFLEFT
 IF SBOPTIMIZE==0 THEN
  EXTENDPRGBF "DEC P"
 ENDIF
 IF SBOPTIMIZE==1 THEN
  I=BFLEFT(I,S$)
 ENDIF
 IF SBMEMOF==0 THEN
  EXTENDPRGBF "IF P<0 THEN"
  IF SBINDENT==0 THEN
   EXTENDPRGBF "REPEAT"
   EXTENDPRGBF "INC P,"+STR$(MEMSIZE)
   EXTENDPRGBF "UNTIL P>=0"
  ENDIF
  IF SBINDENT==1 THEN
   EXTENDPRGBF " REPEAT"
   EXTENDPRGBF "  INC P,"+STR$(MEMSIZE)
   EXTENDPRGBF " UNTIL P>=0"
  ENDIF
  EXTENDPRGBF "ENDIF"
 ENDIF
 IF SBMEMOF==1 THEN
  EXTENDPRGBF "IF P<0 THEN"
  IF SBINDENT==0 THEN
   EXTENDPRGBF "CLS"
   EXTENDPRGBF "DIALOG "+CHR$(34)+"Memory underflow. Execution halted."+CHR$(34)+",0,"+CHR$(34)+"ABORT"+CHR$(34)
   EXTENDPRGBF "END"
  ENDIF
  IF SBINDENT==1 THEN
   EXTENDPRGBF " CLS"
   EXTENDPRGBF " DIALOG "+CHR$(34)+"Memory underflow. Execution halted."+CHR$(34)+",0,"+CHR$(34)+"ABORT"+CHR$(34)
   EXTENDPRGBF " END"
  ENDIF
  EXTENDPRGBF "ENDIF"
 ENDIF
END

DEF PRGINSBFWHILE
 EXTENDPRGBF "WHILE MEM[P]!=0"
 IF SBINDENT==1 THEN
  INC ICOUNT
 ENDIF
END

DEF PRGINSBFWEND
 IF SBINDENT==1 THEN
  DEC ICOUNT
 ENDIF
 EXTENDPRGBF "WEND"
END

DEF PRGINSBFPRINT
 IF SBCHR13==0 THEN
  EXTENDPRGBF "PRINT CHR$(MEM[P]);"
 ENDIF
 IF SBCHR13==1 THEN
  EXTENDPRGBF "IF MEM[P]!=13 THEN"
  IF SBINDENT==0 THEN
   EXTENDPRGBF "PRINT CHR$(MEM[P]);"
  ENDIF
  IF SBINDENT==1 THEN
   EXTENDPRGBF " PRINT CHR$(MEM[P]);"
  ENDIF
  EXTENDPRGBF "ENDIF"
 ENDIF
END

DEF PRGINSBFINPUT
 IF SBINPUT==0 THEN
  IF SBINPUTEOF==2 THEN
   EXTENDPRGBF "IF IC<LEN(Q$) THEN"
   IF SBINDENT==0 THEN
    EXTENDPRGBF "MEM[P]=ASC(Q$[IC])"
    EXTENDPRGBF "INC IC"
   ENDIF
   IF SBINDENT==1 THEN
    EXTENDPRGBF " MEM[P]=ASC(Q$[IC])"
    EXTENDPRGBF " INC IC"
   ENDIF
   EXTENDPRGBF "ENDIF"
  ELSE
   EXTENDPRGBF "IF IC<LEN(Q$) THEN"
   IF SBINDENT==0 THEN
    EXTENDPRGBF "MEM[P]=ASC(Q$[IC])"
    EXTENDPRGBF "INC IC"
    EXTENDPRGBF "ELSE"
    EXTENDPRGBF "MEM[P]="+SBEOF$
   ENDIF
   IF SBINDENT==1 THEN
    EXTENDPRGBF " MEM[P]=ASC(Q$[IC])"
    EXTENDPRGBF " INC IC"
    EXTENDPRGBF "ELSE"
    EXTENDPRGBF " MEM[P]="+SBEOF$
   ENDIF
   EXTENDPRGBF "ENDIF"
  ENDIF
 ENDIF
 IF SBINPUT==1 THEN
  EXTENDPRGBF "REPEAT"
  IF SBINDENT==0 THEN
   EXTENDPRGBF "Q$=INKEY$()"
  ENDIF
  IF SBINDENT==1 THEN
   EXTENDPRGBF " Q$=INKEY$()"
  ENDIF
  EXTENDPRGBF "UNTIL Q$!="+CHR$(34)+CHR$(34)
  EXTENDPRGBF "MEM[P]=ASC(Q$)"
 ENDIF
END

DEF PRGINSBFOPTA
 EXTENDPRGBF "MEM[P]=0"
END

DEF BFINC(I,S$)
 VAR J,K
 FOR J=I TO LEN(S$)-1
  IF MID$(S$,J,1)=="+" THEN
   INC K
  ELSE
   EXTENDPRGBF "INC MEM[P],"+STR$(K)
   EXTENDPRGBF "IF MEM[P]>"+BITU$+" THEN"
   IF SBINDENT==0 THEN
    EXTENDPRGBF "REPEAT"
    EXTENDPRGBF "DEC MEM[P],"+BITC$
    EXTENDPRGBF "UNTIL MEM[P]<="+BITU$
   ENDIF
   IF SBINDENT==1 THEN
    EXTENDPRGBF " REPEAT"
    EXTENDPRGBF "  DEC MEM[P],"+BITC$
    EXTENDPRGBF " UNTIL MEM[P]<="+BITU$
   ENDIF
   EXTENDPRGBF "ENDIF"
   RETURN I+(K-1)
  ENDIF
 NEXT
 EXTENDPRGBF "INC MEM[P],"+STR$(K)
 EXTENDPRGBF "IF MEM[P]>"+BITU$+" THEN"
 IF SBINDENT==0 THEN
  EXTENDPRGBF "REPEAT"
  EXTENDPRGBF "DEC MEM[P],"+BITC$
  EXTENDPRGBF "UNTIL MEM[P]<="+BITU$
 ENDIF
 IF SBINDENT==1 THEN
  EXTENDPRGBF " REPEAT"
  EXTENDPRGBF "  DEC MEM[P],"+BITC$
  EXTENDPRGBF " UNTIL MEM[P]<="+BITU$
 ENDIF
 EXTENDPRGBF "ENDIF"
 RETURN I+(K-1)
END

DEF BFDEC(I,S$)
 VAR J,K
 FOR J=I TO LEN(S$)-1
  IF MID$(S$,J,1)=="-" THEN
   INC K
  ELSE
   EXTENDPRGBF "DEC MEM[P],"+STR$(K)
   EXTENDPRGBF "IF MEM[P]<"+BITL$+" THEN"
   IF SBINDENT==0 THEN
    EXTENDPRGBF "REPEAT"
    EXTENDPRGBF "INC MEM[P],"+BITC$
    EXTENDPRGBF "UNTIL MEM[P]>"+BITL$+"-1"
   ENDIF
   IF SBINDENT==1 THEN
    EXTENDPRGBF " REPEAT"
    EXTENDPRGBF "  INC MEM[P],"+BITC$
    EXTENDPRGBF " UNTIL MEM[P]>="+BITL$
   ENDIF
   EXTENDPRGBF "ENDIF"
   RETURN I+(K-1)
  ENDIF
 NEXT
 EXTENDPRGBF "DEC MEM[P],"+STR$(K)
 EXTENDPRGBF "IF MEM[P]<"+BITL$+" THEN"
 IF SBINDENT==0 THEN
  EXTENDPRGBF "REPEAT"
  EXTENDPRGBF "INC MEM[P],"+BITC$
  EXTENDPRGBF "UNTIL MEM[P]>="+BITL$
 ENDIF
 IF SBINDENT==1 THEN
  EXTENDPRGBF " REPEAT"
  EXTENDPRGBF "  INC MEM[P],"+BITC$
  EXTENDPRGBF " UNTIL MEM[P]>="+BITL$
 ENDIF
 EXTENDPRGBF "ENDIF"
 RETURN I+(K-1)
END

DEF BFRIGHT(I,S$)
 VAR J,K
 FOR J=I TO LEN(S$)-1
  IF MID$(S$,J,1)==">" THEN
   INC K
  ELSE
   EXTENDPRGBF "INC P,"+STR$(K)
   RETURN I+(K-1)
  ENDIF
 NEXT
 EXTENDPRGBF "INC P,"+STR$(K)
 RETURN I+(K-1)
END

DEF BFLEFT(I,S$)
 VAR J,K
 FOR J=I TO LEN(S$)-1
  IF MID$(S$,J,1)=="<" THEN
   INC K
  ELSE
   EXTENDPRGBF "DEC P,"+STR$(K)
   RETURN I+(K-1)
  ENDIF
 NEXT
 EXTENDPRGBF "DEC P,"+STR$(K)
 RETURN I+(K-1)
END

'----

